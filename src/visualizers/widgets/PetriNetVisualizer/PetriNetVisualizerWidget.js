/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Fri Aug 07 2022 02:50:27 GMT-0700 (Pacific Daylight Time).
 */

define(['jointjs', 'css!./styles/PetriNetVisualizerWidget.css'], function (joint) {
    'use strict';

    var WIDGET_CLASS = 'petri-net-visualizer';

    function PetriNetVisualizerWidget(logger, container) {
        this._logger = logger.fork('Widget');

        this._el = container;

        this.nodes = {};
        this._initialize();

        this._logger.debug('ctor finished');
    }

    PetriNetVisualizerWidget.prototype._initialize = function () {
        var width = this._el.width(),
            height = this._el.height(),
            self = this;

        // set widget class
        this._el.addClass(WIDGET_CLASS);

        // create a joint graph to represent the PetriNet
        this._jointPetriNet = new joint.dia.Graph;
        this._jointPaper = new joint.dia.Paper({
            el: this._el,
            width: width,
            height: height,
            model: this._jointPetriNet,
            interactive: false
        });

        this._jointPaper.on('element:pointerclick', function (elementView) {
            const currentElement = elementView.model;
            if (self._petriNet) {
                const pn = self._petriNet;
                const transitionPath = pn.jointId2transition[currentElement.id];
                if (transitionPath) {
                    self._setCurrentPlaces(transitionPath);
                }
            }
        });
    };

    PetriNetVisualizerWidget.prototype.onWidgetContainerResize = function (width, height) {
        this._logger.debug('Widget is resizing...');
    };

    PetriNetVisualizerWidget.prototype.isTransitionEnabled = function (trId) {
        const self = this;
        const pn = self._petriNet;
        const inplaces = pn.transitions[trId].inplaces;
        const trName = pn.transitions[trId].name;

        let res = true;
        for (let inpl of inplaces) {
            const pl = pn.places[inpl.node];
            if (pl.tokens === 0) {
                res = false;
                break;
            }
        }
        return res;
    }

    // This method draws the tokens on the ui
    PetriNetVisualizerWidget.prototype.drawTokens = function (place, placeMeta, tokenDiameter) {
        var self = this;

        placeMeta.childVertexes = placeMeta.childVertexes || [];
        placeMeta.childVertexes.forEach(v => place.graph.getCell(v).remove());

        // The center is the same for all circles
        const vpos = place.attributes.position;
        const vr = tokenDiameter / 2;
        var cx = vpos.x + vr;
        var cy = vpos.y + vr;

        var radius_of_satellites_from_center = 28;
        var radius_of_small_circles = 4
        var number_of_satellite_circles = placeMeta.tokens;

        placeMeta.childVertexes = [];

        //  The angle increments for each circle drawn
        for (var n = 0; n < number_of_satellite_circles; n++) {

            //  Find how many degrees separate each circle
            var degrees_of_separation = 360 / number_of_satellite_circles;

            var angle_as_degrees = degrees_of_separation * n;

            var coordinates = self.polarToCartesian(cx, cy, radius_of_satellites_from_center, angle_as_degrees);

            let vertex = new joint.shapes.standard.Circle({
                position: {
                    x: coordinates.x - radius_of_small_circles,
                    y: coordinates.y - radius_of_small_circles
                },
                size: { width: radius_of_small_circles * 2, height: radius_of_small_circles * 2 },
                attrs: {
                    body: {
                        fill: 'blue',
                        cursor: 'pointer'
                    },
                }
            });
            vertex.addTo(place.graph);
            placeMeta.childVertexes.push(vertex.id);
        }
    }


    // Initilization of the PetriNet Visualization
    PetriNetVisualizerWidget.prototype.initPetriNet = function (petriNetDescriptor) {
        const self = this;

        // Sotre the PetriNet in the _originalPetriNet
        if (self._originalPetriNet) {
            self._petriNet = JSON.parse(JSON.stringify(this._originalPetriNet));
        }
        else {
            // store the PetriNet 
            self._originalPetriNet = JSON.parse(JSON.stringify(petriNetDescriptor));
            self._petriNet = petriNetDescriptor;
        }

        self._petriNet.currTransitionPath = self._petriNet.init;
        self._jointPetriNet.clear();
        const petriNet = self._petriNet;
        petriNet.jointId2place = {};
        petriNet.jointId2transition = {};
        petriNet.placesAndTransitions = {};
        Object.keys(petriNet.places).forEach(elemId => {
            let vertex = new joint.shapes.standard.Circle({
                position: petriNet.places[elemId].position,
                size: { width: 70, height: 70 },
                attrs: {
                    body: {
                        fill: "white",
                        cursor: "default"
                    },
                    label: {
                        text: petriNet.places[elemId].name,
                        fill: "black",
                        cursor: "default"
                    }
                }
            });
            vertex.addTo(self._jointPetriNet);
            self.drawTokens(vertex, petriNet.places[elemId], 70);
            petriNet.places[elemId].joint = vertex;
            petriNet.placesAndTransitions[elemId] = petriNet.places[elemId];
            petriNet.jointId2place[vertex.id] = elemId;
        });

        // Process the transitions
        Object.keys(petriNet.transitions).forEach(elemId => {
            const isEnabled = self.isTransitionEnabled(elemId);
            let vertex = new joint.shapes.standard.Rectangle({
                position: petriNet.transitions[elemId].position,
                size: { width: 70, height: 60 },
                attrs: {
                    body: {
                        fill: (isEnabled) ? "lightgreen" : "lightsalmon",
                        cursor: "pointer",
                        stroke: (isEnabled) ? "black" : "red",
                    },
                    label: {
                        text: petriNet.transitions[elemId].name,
                        fill: "black",
                        cursor: "pointer"
                    }
                }
            });
            vertex.addTo(self._jointPetriNet);
            petriNet.transitions[elemId].joint = vertex;
            petriNet.placesAndTransitions[elemId] = petriNet.transitions[elemId];
            petriNet.jointId2transition[vertex.id] = elemId;
        });

        Object.keys(petriNet.placesAndTransitions).forEach(elemId => {
            const elem = petriNet.placesAndTransitions[elemId];
            elem.outplaces.forEach(outplaceArc => {
                elem.jointNext = elem.jointNext || {};
                const link = new joint.shapes.standard.Link({
                    source: { id: elem.joint.id },
                    target: { id: petriNet.placesAndTransitions[outplaceArc.node].joint.id },
                    attrs: {
                        line: {
                            strokeWidth: 1
                        },
                        wrapper: {
                            cursor: 'default'
                        }
                    },
                    labels: [{
                        position: {
                            distance: 0.5,
                            offset: 0,
                            args: {
                                keepGradient: true,
                                ensureLegibility: true
                            }
                        }
                    }]
                });
                link.addTo(self._jointPetriNet);
                elem.jointNext[outplaceArc] = link;
            });
        });

        //now refresh the visualization
        self._jointPaper.updateViews();
        self._decoratePetriNet();
    };

    PetriNetVisualizerWidget.prototype.destroyPetriNet = function () {

    };
    
        // This method Resets the Petrinet
    PetriNetVisualizerWidget.prototype.resetPetriNet = function () {
        this._petriNet.currTransitionPath = this._petriNet.init;
        this.initPetriNet(this._petriNet);
    };


    PetriNetVisualizerWidget.prototype.fireEvent = function (event) {
        const self = this;
        const current = self._petriNet.places[self._petriNet.currTransitionPath];
        const link = current.jointNext[event];
        const linkView = link.findView(self._jointPaper);
        linkView.sendToken(joint.V('circle', { r: 10, fill: 'black' }), { duration: 500 }, function () {
            self._petriNet.currTransitionPath = current.next[event];
            self._decoratePetriNet();
        });
    };


    PetriNetVisualizerWidget.prototype._animateMove = function () {

    }
    // This method decores the PetriNet
    PetriNetVisualizerWidget.prototype._decoratePetriNet = function () {
        const self = this;
        const petriNet = this._petriNet;
        if (petriNet.currTransitionPath) {
            if (!self.isTransitionEnabled(petriNet.currTransitionPath)) {
                return;
            }

            const currTransition = petriNet.transitions[petriNet.currTransitionPath];
            currTransition.inplaces.forEach(ip => {
                const pl = petriNet.places[ip.node];
                pl.tokens--;
                self.drawTokens(pl.joint, pl, 70);
            });

            currTransition.outplaces.forEach(op => {
                const pl = petriNet.places[op.node];
                pl.tokens++;
                self.drawTokens(pl.joint, pl, 70);
            });

            // update all transitions
            Object.entries(petriNet.transitions).forEach(e => {
                const color = self.isTransitionEnabled(e[0]) ? "lightgreen" : "lightsalmon";
                e[1].joint.attr("body/fill", color);
                e[1].joint.attr("body/stroke", color === "lightgreen" ? "black" : "red");
            });
        }
    };

    PetriNetVisualizerWidget.prototype._setCurrentPlaces = function (transitionPath) {
        this._petriNet.currTransitionPath = transitionPath;
        this._decoratePetriNet();
    };


    /* * * * * * * * Visualizer event handlers * * * * * * * */

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    PetriNetVisualizerWidget.prototype.destroy = function () {
    };

    PetriNetVisualizerWidget.prototype.onActivate = function () {
        this._logger.debug('PetriNetVisualizerWidget has been activated');
    };

    PetriNetVisualizerWidget.prototype.onDeactivate = function () {
        this._logger.debug('PetriNetVisualizerWidget has been deactivated');
    };

    PetriNetVisualizerWidget.prototype.onNodeClick = function (/*id*/) {
        // This currently changes the active node to the given id and
        // this is overridden in the controller.
    };

    PetriNetVisualizerWidget.prototype.onBackgroundDblClick = function () {
        this._el.append('<div>Background was double-clicked!!</div>');
    };


    PetriNetVisualizerWidget.prototype.polarToCartesian = function (center_x, center_y, radius, angle_in_degrees) {
        var return_value = {}
        var angle_in_radians = angle_in_degrees * Math.PI / 180.0;
        return_value.x = center_x + radius * Math.cos(angle_in_radians);
        return_value.y = center_y + radius * Math.sin(angle_in_radians);
        return return_value;
    }


    return PetriNetVisualizerWidget;

});
